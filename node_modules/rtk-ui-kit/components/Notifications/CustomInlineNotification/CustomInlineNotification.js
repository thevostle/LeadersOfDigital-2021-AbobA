'use strict';
var PropTypes = require('prop-types');

var __createBinding =
  (void 0 && (void 0).__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, {
          enumerable: true,
          get: function get() {
            return m[k];
          },
        });
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });

var __setModuleDefault =
  (void 0 && (void 0).__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', {
          enumerable: true,
          value: v,
        });
      }
    : function (o, v) {
        o['default'] = v;
      });

var __importStar =
  (void 0 && (void 0).__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod) {
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
      }

    __setModuleDefault(result, mod);

    return result;
  };

var __importDefault =
  (void 0 && (void 0).__importDefault) ||
  function (mod) {
    return mod && mod.__esModule
      ? mod
      : {
          default: mod,
        };
  };

Object.defineProperty(exports, '__esModule', {
  value: true,
});

var react_1 = __importStar(require('react'));

var react_transition_group_1 = require('react-transition-group');

var function_1 = require('../../../utils/function');

var components_1 = require('../../../constants/components');

var constants_1 = require('../constants');

var hooks_1 = require('../hooks');

var useThemeContext_1 = require('../../../hooks/useThemeContext');

var utils_1 = require('../utils');

var Typography_1 = __importDefault(require('../../Typography/Typography'));

var NotificationCloseButton_1 = __importDefault(
  require('../components/NotificationCloseButton/NotificationCloseButton')
);

var styles_1 = require('../styles');

var styles_2 = require('./styles');

var CustomInlineNotification = function CustomInlineNotification(props) {
  var themeConfig = useThemeContext_1.useThemeContext().themeConfig;
  var _a = props.color,
    color = _a === void 0 ? components_1.SYSTEM_COLORS.info : _a,
    _b = props.shape,
    shape = _b === void 0 ? themeConfig.shape : _b,
    icon = props.icon,
    title = props.title,
    _c = props.titleColor,
    titleColor = _c === void 0 ? components_1.TYPOGRAPHY_COLORS.main : _c,
    subtitle = props.subtitle,
    _d = props.actionButtons,
    actionButtons = _d === void 0 ? [] : _d,
    _e = props.onOpen,
    onOpen = _e === void 0 ? function_1.noop : _e,
    _f = props.onClose,
    onClose = _f === void 0 ? function_1.noop : _f,
    _g = props.hideCloseButton,
    hideCloseButton = _g === void 0 ? false : _g,
    className = props.className,
    style = props.style;

  var _h = hooks_1.useNotifications({
      onOpen: onOpen,
      onClose: onClose,
    }),
    handleCloseNotification = _h.handleCloseNotification,
    isOpen = _h.isOpen;

  var _j = hooks_1.useNotificationsButtons(),
    buttonsHeight = _j.buttonsHeight,
    buttonsRef = _j.buttonsRef;

  var buttons = utils_1.createActionButtons(actionButtons);
  var notificationIcon =
    icon && react_1.default.createElement(styles_2.StyledCustomInlineNotificationIcon, null, icon);
  var notificationTitle =
    title &&
    react_1.default.createElement(
      Typography_1.default,
      {
        variant: components_1.TYPOGRAPHY_VARIANTS.accentS,
        tag: 'h2',
        color: titleColor,
      },
      title
    );
  var notificationSubtitle =
    subtitle &&
    react_1.default.createElement(
      Typography_1.default,
      {
        variant: components_1.TYPOGRAPHY_VARIANTS.bodyM,
        tag: 'p',
        color: components_1.TYPOGRAPHY_COLORS.caption,
      },
      subtitle
    );
  var notificationButtons =
    buttons.length > 0 &&
    react_1.default.createElement(
      styles_2.StyledCustomInlineNotificationActionButtons,
      {
        ref: buttonsRef,
      },
      buttons.map(function (elem) {
        return react_1.default.createElement(
          react_1.Fragment,
          {
            key: elem.id,
          },
          elem.button,
          elem.id < buttons.length &&
            react_1.default.createElement(styles_1.StyledNotificationActionButtonDivider, {
              height: buttonsHeight,
            })
        );
      })
    );
  var notificationCloseButton =
    !hideCloseButton &&
    react_1.default.createElement(
      styles_2.StyledCustomInlineNotificationIcon,
      null,
      react_1.default.createElement(NotificationCloseButton_1.default, {
        onClick: handleCloseNotification,
        shape: shape,
      })
    );

  return react_1.default.createElement(
    react_transition_group_1.CSSTransition,
    {
      in: isOpen,
      classNames: 'inline-notifications',
      timeout: constants_1.INLINE_NOTIFICATION_TIMEOUT,
      mountOnEnter: true,
      unmountOnExit: true,
    },
    react_1.default.createElement(
      styles_2.StyledCustomInlineNotification,
      {
        shape: shape,
        type: color,
        className: className,
        style: style,
      },
      notificationIcon,
      react_1.default.createElement(
        styles_2.StyledCustomInlineNotificationContent,
        null,
        react_1.default.createElement(
          styles_2.StyledCustomInlineNotificationContent,
          null,
          notificationTitle,
          notificationSubtitle
        ),
        notificationButtons
      ),
      notificationCloseButton
    )
  );
};

CustomInlineNotification.propTypes = {
  /**
   * Задает кнопки уведомления
   */
  actionButtons: PropTypes.arrayOf(PropTypes.element),
  /**
   * Задает дополнительные классы для компонента
   */
  className: PropTypes.string,
  /**
   * Задает цвет компонента
   * @default  "info"
   */
  color: PropTypes.oneOf([
    'error',
    'info',
    'primary1',
    'primary2',
    'secondary1',
    'secondary2',
    'success',
    'warning',
  ]),
  /**
   * Прячет кнопку "Закрыть"
   *  @default false
   */
  hideCloseButton: PropTypes.bool,
  /**
   * Задает иконку
   */
  icon: PropTypes.node,
  /**
   * Callback функция, вызываемая при закрытии уведомления
   * @returns {undefined}
   */
  onClose: PropTypes.func,
  /**
   * Callback функция, вызываемая при появлении уведомления
   * @returns {undefined}
   */
  onOpen: PropTypes.func,
  /**
   * Задает скругление, значение по умолчанию берется из темы
   */
  shape: PropTypes.oneOf(['circular', 'geometric', 'rounded']),
  /**
   * Задает дополнительные стили для компонента
   */
  style: PropTypes.object,
  /**
   * Задает подзаголовок уведомления
   */
  subtitle: PropTypes.string,
  /**
   * Задает заголовок уведомления
   */
  title: PropTypes.string,
  /**
   * Задает цвет заголовока
   *  @default "main"
   */
  titleColor: PropTypes.oneOf([
    'caption',
    'description',
    'disabled',
    'error',
    'info',
    'main',
    'primary1',
    'primary2',
    'secondary1',
    'secondary2',
    'success',
    'warning',
  ]),
};

exports.default = CustomInlineNotification;
