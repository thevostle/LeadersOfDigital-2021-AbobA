'use strict';
var PropTypes = require('prop-types');

var __assign =
  (void 0 && (void 0).__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

    return __assign.apply(this, arguments);
  };

var __createBinding =
  (void 0 && (void 0).__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, {
          enumerable: true,
          get: function get() {
            return m[k];
          },
        });
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });

var __setModuleDefault =
  (void 0 && (void 0).__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', {
          enumerable: true,
          value: v,
        });
      }
    : function (o, v) {
        o['default'] = v;
      });

var __importStar =
  (void 0 && (void 0).__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod) {
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
      }

    __setModuleDefault(result, mod);

    return result;
  };

var __rest =
  (void 0 && (void 0).__rest) ||
  function (s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };

var __importDefault =
  (void 0 && (void 0).__importDefault) ||
  function (mod) {
    return mod && mod.__esModule
      ? mod
      : {
          default: mod,
        };
  };

Object.defineProperty(exports, '__esModule', {
  value: true,
});

var react_1 = __importStar(require('react'));

var styles_1 = require('./styles');

var constants_1 = require('./constants');

var utils_1 = require('./utils');

var useOutsideClick_1 = __importDefault(require('../../hooks/useOutsideClick'));

var useThemeContext_1 = require('../../hooks/useThemeContext');

var Tooltip = function Tooltip(props) {
  var themeConfig = useThemeContext_1.useThemeContext().themeConfig;

  var _a = props.shape,
    shape = _a === void 0 ? themeConfig.shape : _a,
    header = props.header,
    text = props.text,
    _b = props.textAlign,
    textAlign = _b === void 0 ? constants_1.DEFAULT_TEXT_ALIGN : _b,
    hint = props.hint,
    _c = props.hintSide,
    hintSide = _c === void 0 ? constants_1.DEFAULT_HINT_POSITION : _c,
    image = props.image,
    _d = props.imageSide,
    imageSide = _d === void 0 ? constants_1.DEFAULT_IMAGE_POSITION : _d,
    _e = props.hideCloseButton,
    hideCloseButton = _e === void 0 ? false : _e,
    _f = props.trigger,
    trigger = _f === void 0 ? constants_1.DEFAULT_TRIGGER : _f,
    _g = props.placement,
    placement = _g === void 0 ? constants_1.DEFAULT_PLACEMENT : _g,
    className = props.className,
    style = props.style,
    children = props.children,
    restProps = __rest(props, [
      'shape',
      'header',
      'text',
      'textAlign',
      'hint',
      'hintSide',
      'image',
      'imageSide',
      'hideCloseButton',
      'trigger',
      'placement',
      'className',
      'style',
      'children',
    ]);

  var tooltipRef = react_1.useRef();
  var tooltipTriggerRef = react_1.useRef();

  var _h = react_1.useState(false),
    isOpen = _h[0],
    setOpen = _h[1];

  var _j = react_1.useState(false),
    isDisabled = _j[0],
    setDisabled = _j[1];

  var _k = react_1.useState(false),
    isImageLoadError = _k[0],
    setImageLoadError = _k[1];

  var _l = react_1.useState(true),
    isCloseButtonVisible = _l[0],
    setCloseButtonVisibility = _l[1];

  var tooltipRect = utils_1.getBoundingClientRect(tooltipRef.current);
  var currentTargetRect = utils_1.getBoundingClientRect(tooltipTriggerRef.current);
  var autoPlacement =
    placement === constants_1.TOOLTIP_PLACEMENTS.auto
      ? utils_1.getAutoPlacement(currentTargetRect, tooltipRect)
      : placement;

  var showTooltip = function showTooltip() {
    if (!isDisabled) {
      setOpen(true);
    }
  };

  var hideTooltip = function hideTooltip() {
    setOpen(false);
  };

  useOutsideClick_1.default(tooltipRef, function (target) {
    if (
      trigger === constants_1.TOOLTIP_TRIGGERS.click &&
      !tooltipTriggerRef.current.contains(target)
    ) {
      hideTooltip();
    }
  });
  react_1.useEffect(function () {
    window.addEventListener('scroll', hideTooltip);
    window.addEventListener('resize', hideTooltip);
    return function () {
      window.removeEventListener('scroll', hideTooltip);
      window.removeEventListener('resize', hideTooltip);
    };
  });
  react_1.useEffect(
    function () {
      setDisabled(!header && !text && !image && !hint);
    },
    [header, text, image, hint]
  );
  react_1.useEffect(
    function () {
      setCloseButtonVisibility(!hideCloseButton && trigger === constants_1.TOOLTIP_TRIGGERS.click);
    },
    [hideCloseButton, trigger]
  );

  var addDefaultImageSrc = function addDefaultImageSrc() {
    setImageLoadError(true);
  };

  var renderCloseButton =
    isCloseButtonVisible &&
    react_1.default.createElement(styles_1.StyledTooltipCloseButton, {
      shape: shape,
      onClick: hideTooltip,
    });

  var renderHeader =
    header && react_1.default.createElement(styles_1.StyledTooltipHeader, null, header);
  var renderText =
    text &&
    react_1.default.createElement(
      styles_1.StyledTooltipText,
      {
        textAlign: textAlign,
      },
      text
    );
  var renderImage =
    image &&
    react_1.default.createElement(
      react_1.default.Fragment,
      null,
      isImageLoadError && react_1.default.createElement(styles_1.StyledTooltipNoImage, null),
      !isImageLoadError &&
        react_1.default.createElement(styles_1.StyledTooltipImage, {
          src: image,
          onError: addDefaultImageSrc,
        })
    );

  var renderHint = hint && react_1.default.createElement(styles_1.StyledTooltipHint, null, hint);
  var renderImageBlock = react_1.default.createElement(
    react_1.default.Fragment,
    null,
    hintSide === constants_1.HINT_POSITIONS.top && renderHint,
    renderImage,
    hintSide === constants_1.HINT_POSITIONS.bottom && renderHint
  );
  var renderContent = react_1.default.createElement(
    react_1.default.Fragment,
    null,
    imageSide === constants_1.IMAGE_POSITIONS.top && renderImageBlock,
    renderText,
    imageSide === constants_1.IMAGE_POSITIONS.bottom && renderImageBlock
  );
  var renderTooltip = react_1.default.createElement(
    styles_1.StyledTooltip,
    __assign(
      {
        shape: shape,
        closeButton: isCloseButtonVisible,
        isOpen: isOpen,
        style: style,
        ref: tooltipRef,
        placement: autoPlacement,
        currentTargetRect: utils_1.getBoundingClientRect(tooltipTriggerRef.current),
      },
      restProps
    ),
    renderCloseButton,
    renderHeader,
    renderContent
  );
  return react_1.default.createElement(
    styles_1.StyledTooltipRoot,
    {
      className: className,
    },
    react_1.default.createElement(
      styles_1.StyledTooltipTrigger,
      {
        onClick: function onClick() {
          return trigger === constants_1.TOOLTIP_TRIGGERS.click && showTooltip();
        },
        onMouseEnter: function onMouseEnter() {
          return trigger === constants_1.TOOLTIP_TRIGGERS.hover && showTooltip();
        },
        onMouseLeave: function onMouseLeave() {
          return trigger === constants_1.TOOLTIP_TRIGGERS.hover && hideTooltip();
        },
        ref: tooltipTriggerRef,
        hasDisabledChildren: utils_1.isDisabledCompatibleChildren(children),
      },
      children
    ),
    renderTooltip
  );
};

Tooltip.propTypes = {
  children: PropTypes.node,
  /**
   * Задает дополнительные классы для компонента, к примеру для переопределения максимальной ширины = 246px
   */
  className: PropTypes.string,
  /**
   * Задает заголовок
   */
  header: PropTypes.string,
  /**
   * Задает отображение кнопки "Закрыть"
   *  @default false
   */
  hideCloseButton: PropTypes.bool,
  /**
   * Задает описание к изображению
   */
  hint: PropTypes.string,
  /**
   * Задает положение описания к изображению относительно изображения
   * @default "bottom"
   */
  hintSide: PropTypes.oneOf(['bottom', 'top']),
  /**
   * Задает путь до картинки
   */
  image: PropTypes.string,
  /**
   * Задает положение изображения относительно основного текста
   * @default "bottom"
   */
  imageSide: PropTypes.oneOf(['bottom', 'top']),
  /**
   * Задает расположение для отображения
   *  @default "auto"
   */
  placement: PropTypes.oneOf([
    'auto',
    'bottom',
    'bottomLeft',
    'bottomRight',
    'left',
    'leftBottom',
    'leftTop',
    'right',
    'rightBottom',
    'rightTop',
    'top',
    'topLeft',
    'topRight',
  ]),
  /**
   * Задает скругление, значение по умолчанию берется из темы
   */
  shape: PropTypes.oneOf(['circular', 'geometric', 'rounded']),
  /**
   * Задает дополнительные стили для компонента
   */
  style: PropTypes.object,
  /**
   * Задает основной текст
   */
  text: PropTypes.node,
  /**
   * Задает выравнивание основного текста
   *  @default "left"
   */
  textAlign: PropTypes.oneOf(['center', 'left']),
  /**
   * Задает событие триггер для отображения
   *  @default "click"
   */
  trigger: PropTypes.oneOf(['click', 'hover']),
};

Tooltip.displayName = 'Tooltip';
exports.default = Tooltip;
