'use strict';
var PropTypes = require('prop-types');

var __assign =
  (void 0 && (void 0).__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

    return __assign.apply(this, arguments);
  };

var __createBinding =
  (void 0 && (void 0).__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, {
          enumerable: true,
          get: function get() {
            return m[k];
          },
        });
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });

var __setModuleDefault =
  (void 0 && (void 0).__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', {
          enumerable: true,
          value: v,
        });
      }
    : function (o, v) {
        o['default'] = v;
      });

var __importStar =
  (void 0 && (void 0).__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod) {
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
      }

    __setModuleDefault(result, mod);

    return result;
  };

var __spreadArray =
  (void 0 && (void 0).__spreadArray) ||
  function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
      to[j] = from[i];
    }

    return to;
  };

var __importDefault =
  (void 0 && (void 0).__importDefault) ||
  function (mod) {
    return mod && mod.__esModule
      ? mod
      : {
          default: mod,
        };
  };

Object.defineProperty(exports, '__esModule', {
  value: true,
});

var react_1 = __importStar(require('react'));

var hooks_1 = require('./hooks');

var useThemeContext_1 = require('../../hooks/useThemeContext');

var function_1 = require('../../utils/function');

var constants_1 = require('../Input/constants');

var constants_2 = require('../Tag/constants');

var types_1 = require('../Input/types');

var styles_1 = require('./styles');

var DropdownMenu_1 = __importDefault(require('../DropdownMenu/DropdownMenu'));

var navigation_1 = require('../Icons/static16/navigation');

var Multiselect = function Multiselect(props) {
  var themeConfig = useThemeContext_1.useThemeContext().themeConfig;
  var _a = props.color,
    color = _a === void 0 ? constants_1.DEFAULT_COLOR : _a,
    _b = props.shape,
    shape = _b === void 0 ? themeConfig.shape : _b,
    label = props.label,
    inputValue = props.value,
    defaultValue = props.defaultValue,
    _c = props.options,
    inputOptions = _c === void 0 ? [] : _c,
    title = props.title,
    _d = props.autoHeight,
    autoHeight = _d === void 0 ? false : _d,
    hint = props.hint,
    error = props.error,
    _e = props.disabled,
    disabled = _e === void 0 ? false : _e,
    _f = props.defaultOpen,
    defaultOpen = _f === void 0 ? false : _f,
    className = props.className,
    style = props.style,
    tagClassName = props.tagClassName,
    tagStyle = props.tagStyle,
    _g = props.onChange,
    onChange = _g === void 0 ? function_1.noop : _g,
    _h = props.onFocus,
    onFocus = _h === void 0 ? function_1.noop : _h,
    _j = props.onBlur,
    onBlur = _j === void 0 ? function_1.noop : _j;
  var ref = react_1.useRef();

  var _k = react_1.useState(defaultOpen),
    isMultiselectOpen = _k[0],
    setIsMultiselectOpen = _k[1];

  var _l = react_1.useState(false),
    displayInputAsFocused = _l[0],
    setDisplayInputAsFocused = _l[1];

  var _m = hooks_1.useMultiselect(
      inputOptions,
      react_1.default.createElement(navigation_1.CheckLarge16, null),
      defaultValue
    ),
    options = _m.options,
    dropdownItems = _m.dropdownItems,
    selectedOptions = _m.selectedOptions,
    updateOptions = _m.updateOptions,
    updateMultiselectInputs = _m.updateMultiselectInputs;

  var isMount = hooks_1.useIsMount();
  var multiselectIcon = react_1.default.createElement(styles_1.StyledIcon, {
    isOpen: isMultiselectOpen,
  });

  var multiselectFloatLabel = selectedOptions.length
    ? types_1.FLOAT_LABEL.always
    : types_1.FLOAT_LABEL.auto;
  react_1.useEffect(
    function () {
      if (!isMount && inputValue !== undefined) {
        updateMultiselectInputs(inputOptions, inputValue);
      } // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [inputOptions, inputValue]
  );
  react_1.useEffect(
    function () {
      setDisplayInputAsFocused(isMultiselectOpen); // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [isMultiselectOpen]
  );

  var selectClick = function selectClick() {
    if (!disabled) setIsMultiselectOpen(!isMultiselectOpen);
  };

  var updateSelectedItem = function updateSelectedItem(item) {
    var updatedOptions = options.map(function (opt) {
      return item === opt.key
        ? __assign(__assign({}, opt), {
            isSelected: !opt.isSelected,
          })
        : opt;
    });

    if (inputValue === undefined) {
      updateOptions(__spreadArray([], updatedOptions));
    }

    onChange(
      updatedOptions
        .filter(function (o) {
          return o.isSelected;
        })
        .map(function (option) {
          return {
            key: option.key,
            value: option.value,
            hint: option.hint,
          };
        })
    );
  };

  var onDropdownItemSelect = function onDropdownItemSelect(key) {
    updateSelectedItem(key);
  };

  var onDropdownClose = function onDropdownClose() {
    setIsMultiselectOpen(false);
  };

  var removeTag = function removeTag(removedTag) {
    updateSelectedItem(removedTag.key);
  };

  var renderDropdown =
    isMultiselectOpen &&
    react_1.default.createElement(DropdownMenu_1.default, {
      options: dropdownItems,
      color: color,
      shape: shape,
      hideOnSelect: false,
      onSelect: onDropdownItemSelect,
      onClose: onDropdownClose,
      title: title,
    });

  var renderHint = function renderHint() {
    var hintText = error || hint;
    return (
      hintText &&
      react_1.default.createElement(
        styles_1.StyledMultiSelectHint,
        {
          shape: shape,
          variant: 'caption',
          error: error,
          isStatic: true,
        },
        hintText
      )
    );
  };

  return react_1.default.createElement(
    styles_1.StyledMultiselectContainer,
    {
      className: className,
      style: style,
    },
    react_1.default.createElement(
      styles_1.StyledMultiselectInputContainer,
      {
        disabled: disabled,
        onClick: selectClick,
        ref: ref,
      },
      react_1.default.createElement(styles_1.StyledMultiselectInput, {
        label: label,
        color: color,
        shape: shape,
        error: error,
        icon: multiselectIcon,
        isFocused: displayInputAsFocused,
        floatLabel: multiselectFloatLabel,
        disabled: disabled,
        onClickIcon: selectClick,
        onFocus: onFocus,
        onBlur: onBlur,
        readOnly: true,
      }),
      react_1.default.createElement(styles_1.MultiselectTagGroup, {
        disabledTags: disabled ? selectedOptions : [],
        autoHeight: autoHeight,
        shape: shape,
        tags: selectedOptions,
        size: 'small',
        view: constants_2.TAG_VIEWS.primary,
        onRemove: removeTag,
        closable: true,
        className: tagClassName,
        style: tagStyle,
      })
    ),
    renderDropdown,
    renderHint()
  );
};

Multiselect.propTypes = {
  /**
   * Определяет, меняется ли высота контрола в зависимости от количества элементов
   *
   *  В значении true - появляется вторая строка с выбранными options
   *  @default false
   */
  autoHeight: PropTypes.bool,
  /**
   * Задает дополнительные классы
   */
  className: PropTypes.string,
  /**
   * Задает основной цвет
   *  @default "primary2"
   */
  color: PropTypes.oneOf(['primary1', 'primary2', 'secondary1', 'secondary2']),
  /**
   * Задает первоначально открытое состояние раскрывающегося списка
   * @default false;
   */
  defaultOpen: PropTypes.bool,
  /**
   * Задает значение по умолчанию, для неуправляемых компонентов.
   * Не используется вместе с value
   * @param value - отображаемое значение
   * @param key - уникальный ключ элемента
   * @param hint - дополнительная подпись
   */
  defaultValue: PropTypes.arrayOf(
    PropTypes.shape({
      hint: PropTypes.string,
      key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
      value: PropTypes.string.isRequired,
    })
  ),
  /**
   * Устанавливает атрибут disabled
   */
  disabled: PropTypes.bool,
  /**
   * Отображает ошибку заполнения поля
   */
  error: PropTypes.string,
  /**
   * Отображает подсказку при заполнения поля
   */
  hint: PropTypes.string,
  /**
   * Задает label
   */
  label: PropTypes.string.isRequired,
  /**
   * Callback функция, вызываемая при потере фокуса
   */
  onBlur: PropTypes.func,
  /**
   * Callback функция, вызываемая при изменении значения
   */
  onChange: PropTypes.func,
  /**
   * Callback функция, вызываемая на фокус
   */
  onFocus: PropTypes.func,
  /**
   * Задаёт список элементов для выбора
   * @param value - отображаемое значение
   * @param key - уникальный ключ элемента
   * @param hint - дополнительная подпись
   */
  options: PropTypes.arrayOf(
    PropTypes.shape({
      hint: PropTypes.string,
      key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
      value: PropTypes.string.isRequired,
    })
  ).isRequired,
  /**
   * Задает скругление, значение по умолчанию берется из темы
   */
  shape: PropTypes.oneOf(['circular', 'geometric', 'rounded']),
  /**
   * Задает дополнительные стили для компонента
   */
  style: PropTypes.object,
  /**
   * Задает дополнительные классы
   */
  tagClassName: PropTypes.string,
  /**
   * Задает дополнительные стили для компонента
   */
  tagStyle: PropTypes.object,
  /**
   * Отображает заголовок для выпадающего списка
   */
  title: PropTypes.string,
  /**
   * Задает значение компонента, используется для управляемых компонентов.
   * Не используется вместе с defaultValue
   * @param value - отображаемое значение
   * @param key - уникальный ключ элемента
   * @param hint - дополнительная подпись
   */
  value: PropTypes.arrayOf(
    PropTypes.shape({
      hint: PropTypes.string,
      key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,
      value: PropTypes.string.isRequired,
    })
  ),
};

exports.default = Multiselect;
