'use strict';
var PropTypes = require('prop-types');

var __assign =
  (void 0 && (void 0).__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

    return __assign.apply(this, arguments);
  };

var __createBinding =
  (void 0 && (void 0).__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, {
          enumerable: true,
          get: function get() {
            return m[k];
          },
        });
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });

var __setModuleDefault =
  (void 0 && (void 0).__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', {
          enumerable: true,
          value: v,
        });
      }
    : function (o, v) {
        o['default'] = v;
      });

var __importStar =
  (void 0 && (void 0).__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod) {
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
      }

    __setModuleDefault(result, mod);

    return result;
  };

var __rest =
  (void 0 && (void 0).__rest) ||
  function (s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };

var __importDefault =
  (void 0 && (void 0).__importDefault) ||
  function (mod) {
    return mod && mod.__esModule
      ? mod
      : {
          default: mod,
        };
  };

Object.defineProperty(exports, '__esModule', {
  value: true,
});

var react_1 = __importStar(require('react'));

var InputMaster_1 = __importDefault(require('../InputMaster'));

var useCombinedRefs_1 = require('../../../hooks/useCombinedRefs');

var useFocus_1 = require('../../../hooks/useFocus');

var useThemeContext_1 = require('../../../hooks/useThemeContext');

var function_1 = require('../../../utils/function');

var CloseSmall_1 = __importDefault(require('../../Icons/navigation/CloseSmall'));

var styles_1 = require('./styles');

var constants_1 = require('./constants');

var rules_1 = require('./rules');

var InputText = react_1.forwardRef(function InputText(props, ref) {
  var themeConfig = useThemeContext_1.useThemeContext().themeConfig;

  var _a = props.onBlur,
    onPropsBlur = _a === void 0 ? function_1.noop : _a,
    _b = props.onFocus,
    onPropFocus = _b === void 0 ? function_1.noop : _b,
    _c = props.onChange,
    onChange = _c === void 0 ? function_1.noop : _c,
    _d = props.onInputClick,
    _onInputClick = _d === void 0 ? function_1.noop : _d,
    _e = props.onInputKeyDown,
    onInputKeyDown = _e === void 0 ? function_1.noop : _e,
    _f = props.onClickIcon,
    onClickIcon = _f === void 0 ? function_1.noop : _f,
    _g = props.onInvalid,
    onInvalid = _g === void 0 ? function_1.noop : _g,
    error = props.error,
    titleError = props.titleError,
    hint = props.hint,
    _h = props.name,
    name = _h === void 0 ? '' : _h,
    required = props.required,
    className = props.className,
    inputIcon = props.icon,
    _j = props.disabled,
    disabled = _j === void 0 ? false : _j,
    _k = props.readOnly,
    readOnly = _k === void 0 ? false : _k,
    _l = props.clearable,
    clearable = _l === void 0 ? false : _l,
    _m = props.shape,
    shape = _m === void 0 ? themeConfig.shape : _m,
    _o = props.color,
    color = _o === void 0 ? constants_1.DEFAULT_COLOR : _o,
    inputValue = props.value,
    defaultValue = props.defaultValue,
    style = props.style,
    _p = props.validationRules,
    validationRules = _p === void 0 ? [rules_1.defaultValidationRule] : _p,
    _q = props.transformationRule,
    transformationRule = _q === void 0 ? rules_1.defaultTrasformationRule : _q,
    restProps = __rest(props, [
      'onBlur',
      'onFocus',
      'onChange',
      'onInputClick',
      'onInputKeyDown',
      'onClickIcon',
      'onInvalid',
      'error',
      'titleError',
      'hint',
      'name',
      'required',
      'className',
      'icon',
      'disabled',
      'readOnly',
      'clearable',
      'shape',
      'color',
      'value',
      'defaultValue',
      'style',
      'validationRules',
      'transformationRule',
    ]);

  var internalRef = react_1.useRef(null);
  var inputRef = useCombinedRefs_1.useCombinedRefs(ref, internalRef);

  var _r = useFocus_1.useFocus(),
    isFocused = _r.isFocused,
    onBlur = _r.onBlur,
    onFocus = _r.onFocus;

  var closeIcon = react_1.default.createElement(CloseSmall_1.default, null);

  var _s = react_1.useState(transformationRule.transform(defaultValue)),
    value = _s[0],
    setValue = _s[1];

  var _t = react_1.useState(true),
    valid = _t[0],
    setValid = _t[1];

  var _u = react_1.useState(false),
    isActiveValidation = _u[0],
    setActiveValidation = _u[1];

  var _v = react_1.useState(),
    validationError = _v[0],
    setValidationError = _v[1];

  var _w = react_1.useState(inputIcon),
    icon = _w[0],
    setIcon = _w[1];

  var updateValidity = function updateValidity(val) {
    var validationRule = validationRules.find(function (rule) {
      return !rule.validate(val);
    });
    setValidationError(
      validationRule === null || validationRule === void 0 ? void 0 : validationRule.error
    );
    setValid(!validationRule);
  };

  var validateValue = function validateValue(val) {
    if (isActiveValidation) {
      updateValidity(val);
    }
  };

  var handleBlur = function handleBlur(event) {
    onBlur();
    onPropsBlur(event);
  };

  var handleChange = function handleChange(event) {
    event.persist();
    event.currentTarget.setCustomValidity('');
    var oldValue = event.target.value;
    var newValue = transformationRule.transform(oldValue);
    validateValue(oldValue);
    var newEvent = Object.create(event);
    newEvent.target.value = newValue;
    onChange(newEvent);
    setValue(newValue);

    if (newValue && !icon && clearable) {
      setIcon(closeIcon);
    }
  };

  var handleFocus = function handleFocus(event) {
    onFocus();
    onPropFocus(event);
  };

  var handleInputKeyDown = function handleInputKeyDown(event) {
    event.persist();
    onInputKeyDown(event, value);
  };

  var handleClickIcon = function handleClickIcon() {
    var _a, _b;

    onClickIcon();

    if (clearable && !inputIcon) {
      setValue('');
      setIcon(null);
      (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
      (_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.focus();
    }
  };

  var onInvalidHandler = function onInvalidHandler(event) {
    if (required && titleError && !event.target.value.trim()) {
      event.currentTarget.setCustomValidity(titleError);
    }

    onInvalid(event);
  };

  var renderError = function renderError() {
    return react_1.default.createElement(
      styles_1.StyledHint,
      {
        shape: shape,
        disabled: false,
        variant: 'caption',
        isStatic: true,
        error: true,
      },
      error || validationError
    );
  };

  var renderHint = function renderHint() {
    return (
      hint &&
      react_1.default.createElement(
        styles_1.StyledHint,
        {
          shape: shape,
          disabled: disabled,
          variant: 'caption',
          error: false,
          isStatic: true,
        },
        hint
      )
    );
  };

  react_1.useEffect(
    function () {
      if (isFocused && clearable && value && !disabled) {
        setIcon(inputIcon || closeIcon);
      } else {
        setIcon(inputIcon);
      }

      updateValidity(value || '');
      setActiveValidation(!valid);
      if (!isFocused && value && transformationRule.onBlurTransform)
        setValue(transformationRule.onBlurTransform(value)); // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [isFocused, inputIcon]
  );
  react_1.useEffect(
    function () {
      var formattedValue = transformationRule.transform(inputValue);

      if (inputValue !== undefined && formattedValue !== value) {
        setValue(formattedValue);
      }
    },
    [value, inputValue, transformationRule]
  );
  return react_1.default.createElement(
    styles_1.StyledRoot,
    {
      className: className,
      style: style,
    },
    react_1.default.createElement(
      InputMaster_1.default,
      __assign(
        {
          ref: inputRef,
        },
        restProps,
        {
          value: value,
          disabled: disabled,
          name: name,
          readOnly: readOnly,
          required: required,
          onInputClick: function onInputClick() {
            return _onInputClick(value);
          },
          onInputKeyDown: handleInputKeyDown,
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus,
          onClickIcon: handleClickIcon,
          onInvalid: onInvalidHandler,
          shape: shape,
          color: color,
          icon: icon,
          clearable: clearable,
          error: error || validationError,
        }
      )
    ),
    error || validationError ? renderError() : renderHint()
  );
});

InputText.propTypes = {
  /**
   * Задает дополнительные классы для компонента
   */
  className: PropTypes.string,
  /**
   * В значении true, при заполнении поля, появится иконка для удаления данных
   */
  clearable: PropTypes.bool,
  /**
   * Задает основной цвет для инпута
   *  @default "primary2"
   */
  color: PropTypes.oneOf(['primary1', 'primary2', 'secondary1', 'secondary2']),
  /**
   * Задает значение по умолчанию, для неуправляемых компонентов.
   *  Не используется вместе с value
   */
  defaultValue: PropTypes.string,
  /**
   * Устанавливает атрибут disabled
   */
  disabled: PropTypes.bool,
  /**
   * Отображает ошибку заполнения поля
   */
  error: PropTypes.string,
  /**
   * Отображает подсказку для заполнения поля
   */
  hint: PropTypes.string,
  /**
   * Добавляет иконку
   */
  icon: PropTypes.node,
  /**
   * Устанавливает атрибут name
   */
  name: PropTypes.string,
  /**
   * Callback функция, вызываемая при потере фокуса
   */
  onBlur: PropTypes.func,
  /**
   * Callback функция, вызываемая при изменении значения
   */
  onChange: PropTypes.func,
  /**
   * Callback функция, вызываемая при клике на иконку
   */
  onClickIcon: PropTypes.func,
  /**
   * Callback функция, вызываемая на фокус
   */
  onFocus: PropTypes.func,
  onInputClick: PropTypes.func,
  onInputKeyDown: PropTypes.func,
  /**
   * Callback функция, вызываемая при невалидном инпуте и required={true}
   */
  onInvalid: PropTypes.func,
  /**
   * Устанавливает атрибут readonly
   */
  readOnly: PropTypes.bool,
  /**
   * Устанавливает атрибут required
   */
  required: PropTypes.bool,
  /**
   * Задает скругление, значение по умолчанию берется из темы
   */
  shape: PropTypes.oneOf(['circular', 'geometric', 'rounded']),
  /**
   * Задает дополнительные стили для компонента
   */
  style: PropTypes.object,
  /**
   * Отображает ошибку во всплывающей подсказке при required={true}
   */
  titleError: PropTypes.string,
  /**
   * Задаёт правила трансформации
   *
   * @param transform - метод, изменяющий значение при вводе
   * @param onBlurTransform - метод, изменяющий значение при потере фокуса
   */
  transformationRule: PropTypes.shape({
    onBlurTransform: PropTypes.func,
    transform: PropTypes.func.isRequired,
  }),
  /**
   * Задаёт правила валидации , а также содержит в себе текст ошибки
   * @param error - текстовое значение ошибки валидации
   * @param validate - метод, валидирующий значение value
   */
  validationRules: PropTypes.arrayOf(
    PropTypes.shape({
      error: PropTypes.string,
      validate: PropTypes.func.isRequired,
    })
  ),
  /**
   * Задает значение компонента, используется для управляемых компонентов.
   *  Не используется вместе с defaultValue
   */
  value: PropTypes.string,
};

InputText.displayName = 'InputText';
exports.default = InputText;
