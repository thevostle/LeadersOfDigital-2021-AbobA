'use strict';
var PropTypes = require('prop-types');

var __assign =
  (void 0 && (void 0).__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

    return __assign.apply(this, arguments);
  };

var __createBinding =
  (void 0 && (void 0).__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, {
          enumerable: true,
          get: function get() {
            return m[k];
          },
        });
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });

var __setModuleDefault =
  (void 0 && (void 0).__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, 'default', {
          enumerable: true,
          value: v,
        });
      }
    : function (o, v) {
        o['default'] = v;
      });

var __importStar =
  (void 0 && (void 0).__importStar) ||
  function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
      for (var k in mod) {
        if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
      }

    __setModuleDefault(result, mod);

    return result;
  };

var __rest =
  (void 0 && (void 0).__rest) ||
  function (s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === 'function')
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };

var __importDefault =
  (void 0 && (void 0).__importDefault) ||
  function (mod) {
    return mod && mod.__esModule
      ? mod
      : {
          default: mod,
        };
  };

Object.defineProperty(exports, '__esModule', {
  value: true,
});

var react_1 = __importStar(require('react'));

var dayjs_1 = __importDefault(require('dayjs'));

var customParseFormat_1 = __importDefault(require('dayjs/plugin/customParseFormat'));

var imask_1 = __importDefault(require('imask'));

var function_1 = require('../../../utils/function');

var utils_1 = require('./utils');

var useThemeContext_1 = require('../../../hooks/useThemeContext');

var constants_1 = require('../constants');

var constants_2 = require('./constants');

var constants_3 = require('../../PickerDate/CalendarYears/constants');

var InputText_1 = __importDefault(require('../InputText/InputText'));

var PickerDate_1 = __importDefault(require('../../PickerDate/PickerDate/PickerDate'));

var Calendar_1 = __importDefault(require('../../Icons/entity/Calendar'));

var styles_1 = require('./styles');

dayjs_1.default.extend(customParseFormat_1.default);
var InputDate = react_1.forwardRef(function InputDate(props, ref) {
  var themeConfig = useThemeContext_1.useThemeContext().themeConfig;

  var _a = props.disabled,
    disabled = _a === void 0 ? false : _a,
    _b = props.shape,
    shape = _b === void 0 ? themeConfig.shape : _b,
    _c = props.color,
    color = _c === void 0 ? constants_1.DEFAULT_COLOR : _c,
    _d = props.dateFormat,
    dateFormat = _d === void 0 ? constants_2.DEFAULT_DATE_FORMAT : _d,
    _e = props.isRange,
    isRange = _e === void 0 ? false : _e,
    minDate = props.minDate,
    maxDate = props.maxDate,
    disabledDates = props.disabledDates,
    activeValue = props.activeDate,
    secondValue = props.secondDate,
    _f = props.onChange,
    onChange = _f === void 0 ? function_1.noop : _f,
    firstDayIndex = props.firstDayIndex,
    daysOfWeek = props.daysOfWeek,
    months = props.months,
    _g = props.minYear,
    minYear = _g === void 0 ? constants_3.MIN_YEAR : _g,
    _h = props.maxYear,
    maxYear = _h === void 0 ? constants_3.MAX_YEAR : _h,
    transformationRule = props.transformationRule,
    _j = props.showTime,
    showTime = _j === void 0 ? false : _j,
    _k = props.onClickIcon,
    onClickIcon = _k === void 0 ? function_1.noop : _k,
    _l = props.onInputClick,
    onInputClick = _l === void 0 ? function_1.noop : _l,
    renderDate = props.renderDate,
    otherProps = __rest(props, [
      'disabled',
      'shape',
      'color',
      'dateFormat',
      'isRange',
      'minDate',
      'maxDate',
      'disabledDates',
      'activeDate',
      'secondDate',
      'onChange',
      'firstDayIndex',
      'daysOfWeek',
      'months',
      'minYear',
      'maxYear',
      'transformationRule',
      'showTime',
      'onClickIcon',
      'onInputClick',
      'renderDate',
    ]);

  var _m = react_1.useState(false),
    isOpenCalendar = _m[0],
    setIsOpenCalendar = _m[1];

  var _o = react_1.useState(false),
    displayInputAsFocused = _o[0],
    setDisplayInputAsFocused = _o[1];

  var _p = react_1.useState(activeValue),
    activeDate = _p[0],
    setActiveDate = _p[1];

  var _q = react_1.useState(secondValue),
    secondDate = _q[0],
    setSecondDate = _q[1];

  var _r = react_1.useState(
      utils_1.parseToInputString(
        {
          start: activeValue,
          end: secondValue,
        },
        {
          isRange: isRange,
          dateFormat: dateFormat,
        }
      )
    ),
    value = _r[0],
    setValue = _r[1];

  react_1.useEffect(
    function () {
      setDisplayInputAsFocused(isOpenCalendar); // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [isOpenCalendar]
  );
  var dateMaskParams = utils_1.getDateMaskParams(dateFormat, minYear, maxYear, minDate, maxDate);
  var dateMask = imask_1.default.createMask(dateMaskParams);
  var dateRangeMask = imask_1.default.createMask({
    mask: 'from' + constants_2.DATE_RANGE_SEPARATOR + 'to',
    blocks: {
      from: dateMaskParams,
      to: dateMaskParams,
    },
  });

  var defaultTransformationRule = {
    transform: function transform(inputValue) {
      if (inputValue === void 0) {
        inputValue = '';
      }

      var isValid = isRange
        ? utils_1.isValidDateRangeFormat(inputValue, dateFormat)
        : utils_1.isValidDateFormat(inputValue, dateFormat);

      if (isValid) {
        return isRange ? dateRangeMask.resolve(inputValue) : dateMask.resolve(inputValue);
      }

      return inputValue;
    },
  };

  var toggleCalendar = function toggleCalendar() {
    if (!disabled) {
      setIsOpenCalendar(!isOpenCalendar);
    }
  };

  var hideCalendar = function hideCalendar() {
    if (isOpenCalendar) {
      setIsOpenCalendar(false);
    }
  };

  var handleSelectDate = function handleSelectDate(start, end) {
    setActiveDate(start);
    setSecondDate(end);
    setIsOpenCalendar(false);
    setDisplayInputAsFocused(false);
    setValue(
      utils_1.parseToInputString(
        {
          start: start,
          end: end,
        },
        {
          isRange: isRange,
          dateFormat: dateFormat,
        }
      )
    );

    onChange(start, end);
  };

  var handleChangeDate = function handleChangeDate(e) {
    var inputValue = e.target.value;
    setValue(inputValue);

    if (utils_1.isValidDateFormat(inputValue, dateFormat)) {
      var valueDate = dayjs_1.default(inputValue, dateFormat).format();
      setActiveDate(new Date(valueDate));
      onChange(new Date(valueDate));
    }
  };

  var handleChangeDateRange = function handleChangeDateRange(e) {
    var inputValue = e.target.value;
    setValue(inputValue);

    if (utils_1.isValidDateRangeFormat(inputValue, dateFormat)) {
      var _a = inputValue.split(constants_2.DATE_RANGE_SEPARATOR),
        dateFrom = _a[0],
        dateTo = _a[1];

      var valueDateFrom = dayjs_1.default(dateFrom, dateFormat).format();
      var valueDateTo = dayjs_1.default(dateTo, dateFormat).format();
      setActiveDate(new Date(valueDateFrom));
      setSecondDate(new Date(valueDateTo));
      onChange(new Date(valueDateFrom), new Date(valueDateTo));
    }
  };

  var handleClickIcon = function handleClickIcon() {
    toggleCalendar();
    onClickIcon();
  };

  var handleInputClick = function handleInputClick(val) {
    toggleCalendar();
    onInputClick(val);
  };

  return react_1.default.createElement(
    styles_1.StyledInputDate,
    null,
    react_1.default.createElement(
      InputText_1.default,
      __assign({}, otherProps, {
        icon: react_1.default.createElement(
          styles_1.StyledInputDateIconWrapper,
          {
            isOpen: isOpenCalendar,
          },
          react_1.default.createElement(Calendar_1.default, null)
        ),
        onClickIcon: handleClickIcon,
        onInputClick: handleInputClick,
        shape: shape,
        isFocused: displayInputAsFocused,
        value: value,
        disabled: disabled,
        onChange: isRange ? handleChangeDateRange : handleChangeDate,
        ref: ref,
        transformationRule: __assign(__assign({}, defaultTransformationRule), transformationRule),
        color: color,
      })
    ),
    react_1.default.createElement(
      styles_1.StyledDropdown,
      {
        shape: shape,
        isOpen: isOpenCalendar,
        onClose: hideCalendar,
      },
      react_1.default.createElement(PickerDate_1.default, {
        onSelect: handleSelectDate,
        activeDate: activeDate,
        secondDate: secondDate,
        isRange: isRange,
        minDate: minDate,
        maxDate: maxDate,
        shape: shape,
        disabledDates: disabledDates,
        firstDayIndex: firstDayIndex,
        daysOfWeek: daysOfWeek,
        months: months,
        minYear: minYear,
        maxYear: maxYear,
        showTime: showTime,
        renderDate: renderDate,
        color: color,
      })
    )
  );
});

InputDate.propTypes = {
  /**
   * Значение активной даты по умолчанию
   */
  activeDate: PropTypes.instanceOf(Date),
  /**
   * Задает основной цвет для инпута
   *  @default "primary2"
   */
  color: PropTypes.oneOf(['primary1', 'primary2', 'secondary1', 'secondary2']),
  /**
   * Задает формат отображения даты
   *  @default DD.MM.YYYY
   */
  dateFormat: PropTypes.string,
  /**
   * Задает названия дней недели
   *  @default ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс']
   */
  daysOfWeek: PropTypes.arrayOf(PropTypes.string),
  /**
   * Устанавливает атрибут disabled
   */
  disabled: PropTypes.bool,
  /**
   * Задает дизейбленые даты, которые нельзя выбрать
   */
  disabledDates: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
  /**
   * Задает индекс первого дня недели
   * @default 1
   */
  firstDayIndex: PropTypes.number,
  /**
   * Дает возможность выбрать период из двух дат
   *  @default false
   */
  isRange: PropTypes.bool,
  /**
   * Задает максимальную дату для выбора
   */
  maxDate: PropTypes.instanceOf(Date),
  /**
   * Задает максимальный отображаемый год в календаре, по умолчанию текущий + 10
   * @default 2031
   */
  maxYear: PropTypes.number,
  /**
   * Задает минимальную дату для выбора
   */
  minDate: PropTypes.instanceOf(Date),
  /**
   * Задает минимальный отображаемый год в календаре
   * @default 1980
   */
  minYear: PropTypes.number,
  /**
   * Задает названия месяцов
   *  @default [
   * 'Январь',
   * 'Февраль',
   * 'Март',
   * 'Апрель',
   * 'Май',
   * 'Июнь',
   * 'Июль',
   * 'Август',
   * 'Сентябрь',
   * 'Октябрь',
   * 'Ноябрь',
   * 'Декабрь',
   * ]
   */
  months: PropTypes.arrayOf(PropTypes.string),
  /**
   * Callback функция, вызываемая при изменении значения
   * @param activeDate - выбранная дата
   * @param secondDate - вторая выбранная дата
   */
  onChange: PropTypes.func,
  /**
   * Callback функция, вызываемая при клике на иконку
   */
  onClickIcon: PropTypes.func,
  onInputClick: PropTypes.func,
  /**
   * Функция, которая дает возможность кастомного вывода даты
   * @param date - дата
   */
  renderDate: PropTypes.func,
  /**
   * Значение второй даты по умолчанию (когда isRange = true)
   */
  secondDate: PropTypes.instanceOf(Date),
  /**
   * Задает скругление, значение по умолчанию берется из темы
   */
  shape: PropTypes.oneOf(['circular', 'geometric', 'rounded']),
  /**
   * Добавляет возможност выбора времени PickerTime (не работает при isRange = true)
   * @default false
   */
  showTime: PropTypes.bool,
  /**
   * Задаёт правила трансформации
   *
   * @param transform - метод, изменяющий значение при вводе
   * @param onBlurTransform - метод, изменяющий значение при потере фокуса
   */
  transformationRule: PropTypes.shape({
    onBlurTransform: PropTypes.func,
    transform: PropTypes.func.isRequired,
  }),
};

InputDate.displayName = 'InputDate';
exports.default = InputDate;
